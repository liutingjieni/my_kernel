![1604990278656](/tmp/1604990278656.png)

1. 中断描述符表打印地址乱码
   问题: section .data后面加了':', 这样写导致intr%1entry写在了汇编指令中, 成了执行语句, 如果可以执行到这,也会发生未知错误, 也许CPU会将它当成某个指令去执行
         去掉':'后, section .data为同一个节名称, 所以会将他们自动合并同一个段, 所以地址连续.
2. 中断描述表地址正确, 无法执行中断处理程序

![1605003637367](/tmp/1605003637367.png)

3. make不更新, 没解决
   解决: commmand make all
4. kernel有一个物理内存池, 一半用户进程, 一半内核. 

  每个进程都有一个自己的虚拟内存池原因: 虽然多个进程可以拥有相同的虚拟地址, 但究其原因, 是因为这些虚拟地址所对应的物理地址是不同的. 但是, 在同一进程内的虚拟地址必然是唯一的, 这通常是由链接器为其分配的, 由链接器负责虚拟地址(程序内地址)的唯一性. 但进程在运行时可以动态从堆中申请内存, 系统为其分配的虚拟地址也属于此进程的虚拟地址空间, 也必须要保证虚拟地址的唯一性, 所以, 用位图来来记录虚拟地址的分配情况

5. 获取物理内存容量 loader.asm :total_mem_bytes 物理地址为0xb03(原0xb00),
   tss中添加tss段描述符和用户程序段描述符, 添加位置+3, 指令的影响, 段描述标的位置 + 3

6. 第一次分配pte p = 1 显示已分配
7. 段错误 未初始化thread_init()
8. make_main_threadassert(elem_find(&thread_all_list, &main_thread->all_list_tag))
9. 时钟中断号为20, 但是未初始化20端口的中断处理函数, 导致中断号是0xe或者0x6, 然后去处理, 猜想是未处理正确端口号, 导致中断未处理, 一直触发, 无法回到正常的执行流
